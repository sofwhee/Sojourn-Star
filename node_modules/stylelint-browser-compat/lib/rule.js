"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ruleName = exports.plugin = exports.meta = exports.messages = void 0;
var _browserCompatData = _interopRequireDefault(require("@mdn/browser-compat-data"));
var _browserslist = _interopRequireDefault(require("browserslist"));
var _lodash = _interopRequireDefault(require("lodash.get"));
var _stylelint = _interopRequireDefault(require("stylelint"));
var _collect_features = require("./collect_features");
var _is_supported = require("./is_supported");
var _options = require("./options");
var _parse_browserslist_version = require("./parse_browserslist_version");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const ruleName = exports.ruleName = 'plugin/browser-compat';
const messages = exports.messages = _stylelint.default.utils.ruleMessages(ruleName, {
  disallowPrefix: featureName => {
    return `${featureName} with vendor prefix is not allowed by stylelint config.`;
  },
  featureIsNotInCompatData: featureId => {
    return `No information was found for "${featureId}" feature. Please report the issue at the following URL: https://github.com/3846masa/stylelint-browser-compat/issues/new`;
  },
  rejected: (featureName, targets, mdnUrl) => {
    if (mdnUrl) {
      return `${featureName} is not supported in ${targets}. See ${mdnUrl}.`;
    }
    return `${featureName} is not supported in ${targets}.`;
  }
});
const meta = exports.meta = {
  url: 'https://github.com/3846masa/stylelint-browser-compat'
};
const rule = (enabled, passedOptions) => {
  return async (postcssRoot, postcssResult) => {
    if (!enabled) {
      return;
    }
    const parseOptionsResult = _options.ruleOptionsSchema.safeParse(passedOptions);
    const validOptions = _stylelint.default.utils.validateOptions(postcssResult, ruleName, {
      actual: passedOptions,
      optional: true,
      possible: () => parseOptionsResult.success
    });
    if (!validOptions || !parseOptionsResult.success) {
      return;
    }
    const options = parseOptionsResult.data;
    const versions = (0, _browserslist.default)(options.browserslist ?? null, {
      path: postcssResult.root.source?.input.file ?? false
    });
    const targets = (0, _parse_browserslist_version.parseBrowsersListVersion)(versions);
    const features = await (0, _collect_features.collectFeatures)({
      container: postcssRoot,
      ignoreFeatures: new Set(options.allow.features)
    });
    for (const feature of features) {
      const compat = (0, _lodash.default)(_browserCompatData.default.css, feature.id);
      if (compat?.__compat == null) {
        _stylelint.default.utils.report({
          endIndex: feature.endIndex,
          index: feature.index,
          message: messages.featureIsNotInCompatData(feature.id),
          node: feature.node,
          result: postcssResult,
          ruleName
        });
        continue;
      }
      const {
        mdn_url: mdnUrl,
        support: supportBlock
      } = compat.__compat;
      if (!options.allow.prefix && feature.prefix != null) {
        _stylelint.default.utils.report({
          endIndex: feature.endIndex,
          index: feature.index,
          message: messages.disallowPrefix(feature.name),
          node: feature.node,
          result: postcssResult,
          ruleName
        });
        continue;
      }
      const notSupportedTargets = targets.filter(target => {
        return !(0, _is_supported.isSupported)(supportBlock, target, {
          allow: options.allow
        });
      });
      if (notSupportedTargets.length === 0) {
        continue;
      }
      const notSupportedTargetText = Array.from(new Map(notSupportedTargets.map(target => [target.target.name, target])).values()).map(target => `${target.target.name} ${target.versionString}`).join(', ');
      _stylelint.default.utils.report({
        endIndex: feature.endIndex,
        index: feature.index,
        message: messages.rejected(feature.name, notSupportedTargetText, mdnUrl ?? ''),
        node: feature.node,
        result: postcssResult,
        ruleName
      });
    }
  };
};
rule.messages = messages;
rule.ruleName = ruleName;
const plugin = exports.plugin = _stylelint.default.createPlugin(ruleName, rule);